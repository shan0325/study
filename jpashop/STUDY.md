## 1. jpa 사용 이유
자바의 객체지향과 DB는 서로 패러다임이 달라 DB 구조에 맞게 개발을 진행해야 했다.
그래서 편하게 개발하기 위해 나온게 자바의 jdbc, 스프링 JdbcTemplate, ibatis 등이 있다.
하지만 여전히 DB에 의존적이기 때문에 이것으로 개발을 하다 보면 뭔가 pretty 하지 못하고 또 객체지향적으로 개발할 수가 없었다.
이전에 개발했을 시 하나하나 테이블에 맞게 VO를 만들고 최대한 응집도 및 객체지향적으로 개발하려고 노력했었던 적이 있지만
하다보면 테이블 JOIN에서 어쩔 수 없이 공통VO 만들어 상속받아 필요한 필드들 모두 넣어 사용하게 되었다.
그리고 그외에 거의 모든 프로젝트는 Map을 사용하여 CRUD를 개발하는 방식이였다.
아무리 pretty하게 개발하려고 해도 객체지향적으로 개발하기에는 많은 무리가 있었다.
객체지향과 DB 즉 이러한 패러다임의 불일치를 해결하고자 나온게 ORM 이다.
객체는 객체대로 설계하고, DB는 DB대로 설계하여 ORM은 그 중간에서 Mapping 해주는 방식이였다.
지금은 자바의 JPA가 ORM 기술 표준으로 자리잡고 있다.
이제 SQL 중심적인 개발에서 객체 중심으로 개발을 시작해보자.

##2. 영속성 컨텍스트
- JPA를 이해하는데 가장 중요한 용어이다.
- 엔티티를 영구 저장하는 환경이라는 뜻이다.
- 어플리케이션과 DB사이에서 객체를 보관하는 가상의 DB같은 역할을 한다.
- 서비스별로 하나의 EntityManager Factory가 존재하며 Entity Manager Factory에서 디비에 접근하는 트랜잭션이 생길 때 마다 쓰레드 별로 Entity Manager를 생성하여 영속성 컨텍스트에 접근한다!!
- EntityManager에 엔티티를 저장하거나 조회하면 EntityManager는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 EntityManager를 생성할 때 만들어지며 EntityManager를 통해 영속성 컨텍스트에 접근하고 관리한다.
- 1차 캐시
    - 1차 Cache조회의 흐름
        1. 1차 캐시에서 탐색한 ID값의 엔티티를 찾는다.
        2-1. 탐색한 결과 해당 엔티티가 1차 캐시에 존재하면 값을 가져온다.
        2-2. 탐색 결과가 1차 캐시에 존재하지 않다면 DB에서 값을 조회하고 조회한 데이터를 엔티티로 생성해 1차 캐시에 저장한다. (해당 엔티티를 영속 상태로 만든다.)
        3. 조회한 엔티티를 반환한다.
    - 1차 캐시는 서로 공유하지 않고 하나의 쓰레드가 시작할때부터 끝날때까지 잠깐 사용하는 글로벌하지 않는 캐시이다.
    - 100명 한테 요청 100개 오면, 엔티티 매니저 100개 생기고 1차캐시도 100개 생긴다. 스레드 종료되면, 그때 다 사라진다.
    - 트랜잭션의 범위 안에서만 사용하는 굉장히 짧은 캐시 레이어이다.
    - 전체에서 쓰는 글로벌 캐시는 2차 캐시라고 한다.

##3. 스프링의 엔티티 매니저는?
엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성
문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.
하지만 일반적으로 스프링은 싱글톤기반으로 빈을 관리하고 있는데
그럼 스프링에서 엔티티 매니저가 한 개만 생성되어 스레드마다 공유되면 동시성 문제가 발생하지 않을까 궁금해졌다.
확인해본 결과 위의 엔티티 매니저는 싱글톤이지만 동시성 문제가 발생하지 않는다.
단 스프링 컨테이너가 초기화되면서 @PersistenceContext 애노테이션으로 주입받은 EntityManager를 Proxy로 감싼다.
이후 EntityManager 호출 시 마다 Proxy를 통해 EntityManager를 생성 하여 Thread-Safety를 보장 한다.

쉽게 얘기하면
스프링 프레임워크는 실제 EntityManager를 주입하는 것이 아니라, 사실은 실제 EntityManager를 연결해주는 가짜 EntityManager를 주입해둡니다.
그리고 이 EntityManager를 호출하면, 현재 데이터베이스 트랜잭션과 관련된 실제 EntityManager를 호출해줍니다.
덕분에 개발자는 동시성 이슈에 대한 고민없이, 쉽게 개발할 수 있습니다.
관련해서 JPA 책 13.1 트랜잭션 범위의 영속성 컨텍스트를 참고해보시면 더 자세한 내용을 이해하실 수 있습니다.

- 출처
    - https://www.inflearn.com/questions/254519
    - https://lng1982.tistory.com/276
    - https://jaeho214.tistory.com/73
